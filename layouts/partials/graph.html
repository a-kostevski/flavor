{{- /*
  Graph Partial - Zettelkasten knowledge graph visualization

  Shows connections between pages based on:
  1. Direct wikilinks (solid lines, primary)
  2. Shared tags (dashed lines, secondary)
*/ -}}

{{- $height := .Site.Params.graph.height | default "24rem" -}}

<div id="content-graph" class="border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-800 overflow-hidden" style="height: {{ $height }};">
  <div id="graph-loading" class="flex items-center justify-center h-full text-gray-500 dark:text-gray-400">
    Loading graph...
  </div>
</div>

{{- /* Include D3.js */ -}}
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

{{- /* Build page lookup maps for link resolution */ -}}
{{- $pagesByTitle := dict -}}
{{- $pagesByFilename := dict -}}
{{- $pagesById := dict -}}
{{- $pagesByAlias := dict -}}

{{- range .Site.RegularPages -}}
  {{- $pagesByTitle = merge $pagesByTitle (dict .Title .RelPermalink) -}}
  {{- if .File -}}
    {{- $filename := path.Base .File.Path | strings.TrimSuffix ".md" -}}
    {{- $pagesByFilename = merge $pagesByFilename (dict $filename .RelPermalink) -}}
  {{- end -}}
  {{- with .Params.id -}}
    {{- $pagesById = merge $pagesById (dict (string .) $.RelPermalink) -}}
  {{- end -}}
  {{- with .Params.aliases -}}
    {{- range . -}}
      {{- $pagesByAlias = merge $pagesByAlias (dict . $.RelPermalink) -}}
    {{- end -}}
  {{- end -}}
{{- end -}}

<script>
(function() {
  // Graph data from Hugo
  const graphData = {
    nodes: [
      {{- range $index, $page := .Site.RegularPages -}}
      {{- if $index }},{{ end -}}
      {
        "id": "{{ $page.RelPermalink }}",
        "title": "{{ $page.Title | htmlUnescape | safeJS }}",
        "section": "{{ $page.Section }}",
        "type": "{{ $page.Params.type | default "" }}"
      }
      {{- end -}}
    ],
    links: [
      {{- $first := true -}}
      {{- $seenLinks := slice -}}

      {{- /* 1. Extract direct wikilinks from content */ -}}
      {{- range $page := .Site.RegularPages -}}
        {{- $content := $page.RawContent -}}
        {{- $sourcePermalink := $page.RelPermalink -}}

        {{- /* Find [[...]] patterns */ -}}
        {{- $bracketMatches := findRE `\[\[([^\]|]+)` $content -}}
        {{- range $bracketMatches -}}
          {{- $linkTarget := replaceRE `^\[\[` "" . -}}
          {{- $targetPermalink := "" -}}

          {{- /* Check for id: prefix */ -}}
          {{- if hasPrefix $linkTarget "id:" -}}
            {{- $id := strings.TrimPrefix "id:" $linkTarget -}}
            {{- range $.Site.RegularPages -}}
              {{- if eq (string .Params.id) $id -}}
                {{- $targetPermalink = .RelPermalink -}}
              {{- end -}}
            {{- end -}}
          {{- else -}}
            {{- /* Try title */ -}}
            {{- with index $pagesByTitle $linkTarget -}}
              {{- $targetPermalink = . -}}
            {{- end -}}
            {{- /* Try filename */ -}}
            {{- if not $targetPermalink -}}
              {{- with index $pagesByFilename $linkTarget -}}
                {{- $targetPermalink = . -}}
              {{- end -}}
            {{- end -}}
            {{- /* Try alias */ -}}
            {{- if not $targetPermalink -}}
              {{- with index $pagesByAlias $linkTarget -}}
                {{- $targetPermalink = . -}}
              {{- end -}}
            {{- end -}}
          {{- end -}}

          {{- if and $targetPermalink (ne $sourcePermalink $targetPermalink) -}}
            {{- $linkKey := printf "%s|%s|link" $sourcePermalink $targetPermalink -}}
            {{- if not (in $seenLinks $linkKey) -}}
              {{- $seenLinks = $seenLinks | append $linkKey -}}
              {{- if not $first }},{{ end -}}
              {{- $first = false -}}
              {
                "source": {{ $sourcePermalink | jsonify }},
                "target": {{ $targetPermalink | jsonify }},
                "type": "link"
              }
            {{- end -}}
          {{- end -}}
        {{- end -}}

        {{- /* Find wikilink shortcode patterns */ -}}
        {{- $shortcodeMatches := findRE `\{\{<\s*wikilink\s+"([^"]+)"` $content -}}
        {{- range $shortcodeMatches -}}
          {{- $linkTarget := replaceRE `^.*"([^"]+)".*$` "$1" . -}}
          {{- $targetPermalink := "" -}}

          {{- with index $pagesByTitle $linkTarget -}}
            {{- $targetPermalink = . -}}
          {{- end -}}
          {{- if not $targetPermalink -}}
            {{- with index $pagesByFilename $linkTarget -}}
              {{- $targetPermalink = . -}}
            {{- end -}}
          {{- end -}}

          {{- if and $targetPermalink (ne $sourcePermalink $targetPermalink) -}}
            {{- $linkKey := printf "%s|%s|link" $sourcePermalink $targetPermalink -}}
            {{- if not (in $seenLinks $linkKey) -}}
              {{- $seenLinks = $seenLinks | append $linkKey -}}
              {{- if not $first }},{{ end -}}
              {{- $first = false -}}
              {
                "source": {{ $sourcePermalink | jsonify }},
                "target": {{ $targetPermalink | jsonify }},
                "type": "link"
              }
            {{- end -}}
          {{- end -}}
        {{- end -}}
      {{- end -}}

      {{- /* 2. Add tag-based connections (secondary) */ -}}
      {{- range $page := .Site.RegularPages -}}
        {{- range $tag := $page.GetTerms "tags" -}}
          {{- range $otherPage := $.Site.RegularPages -}}
            {{- if ne $page.RelPermalink $otherPage.RelPermalink -}}
              {{- range $otherTag := $otherPage.GetTerms "tags" -}}
                {{- if eq $tag.LinkTitle $otherTag.LinkTitle -}}
                  {{- $linkKey := printf "%s|%s|tag" $page.RelPermalink $otherPage.RelPermalink -}}
                  {{- $reverseLinkKey := printf "%s|%s|tag" $otherPage.RelPermalink $page.RelPermalink -}}
                  {{- if not (or (in $seenLinks $linkKey) (in $seenLinks $reverseLinkKey)) -}}
                    {{- $seenLinks = $seenLinks | append $linkKey -}}
                    {{- if not $first }},{{ end -}}
                    {{- $first = false -}}
                    {
                      "source": {{ $page.RelPermalink | jsonify }},
                      "target": {{ $otherPage.RelPermalink | jsonify }},
                      "type": "tag",
                      "tag": {{ $tag.LinkTitle | jsonify }}
                    }
                  {{- end -}}
                {{- end -}}
              {{- end -}}
            {{- end -}}
          {{- end -}}
        {{- end -}}
      {{- end -}}
    ]
  };

  // Deduplicate links (prioritize direct links over tag links)
  const seenLinks = new Map();
  graphData.links.forEach(link => {
    const key = [link.source, link.target].sort().join('|');
    const existing = seenLinks.get(key);
    // Keep direct links over tag links
    if (!existing || (link.type === 'link' && existing.type === 'tag')) {
      seenLinks.set(key, link);
    }
  });
  graphData.links = Array.from(seenLinks.values());

  // Current page for highlighting
  const currentPage = {{ .RelPermalink | default "/" | jsonify }};

  // Initialize graph
  function initGraph() {
    const container = document.getElementById('content-graph');
    const loading = document.getElementById('graph-loading');

    if (!container || graphData.nodes.length === 0) {
      if (loading) loading.textContent = 'No content to display';
      return;
    }

    const width = container.clientWidth;
    const height = container.clientHeight;

    // Clear loading message
    if (loading) loading.remove();

    // Colors based on dark mode
    const isDark = document.documentElement.classList.contains('dark');
    const colors = {
      node: isDark ? '#60a5fa' : '#2563eb',
      nodeHover: isDark ? '#93c5fd' : '#3b82f6',
      nodeCurrent: isDark ? '#f472b6' : '#ec4899',
      linkDirect: isDark ? '#60a5fa' : '#3b82f6',  // Direct wikilinks - blue
      linkTag: isDark ? '#4b5563' : '#d1d5db',      // Tag-based - gray
      text: isDark ? '#e5e7eb' : '#374151',
      bg: isDark ? '#1f2937' : '#f9fafb'
    };

    // Section colors
    const sectionColors = {
      articles: '#3b82f6',
      notes: '#10b981',
      projects: '#8b5cf6'
    };

    // Create SVG
    const svg = d3.select(container)
      .append('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height]);

    // Create simulation
    const simulation = d3.forceSimulation(graphData.nodes)
      .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(80))
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(30));

    // Draw links with different styles for direct vs tag-based
    const link = svg.append('g')
      .selectAll('line')
      .data(graphData.links)
      .join('line')
      .attr('stroke', d => d.type === 'link' ? colors.linkDirect : colors.linkTag)
      .attr('stroke-opacity', d => d.type === 'link' ? 0.8 : 0.4)
      .attr('stroke-width', d => d.type === 'link' ? 2 : 1)
      .attr('stroke-dasharray', d => d.type === 'link' ? null : '4,4');

    // Draw nodes
    const node = svg.append('g')
      .selectAll('g')
      .data(graphData.nodes)
      .join('g')
      .attr('cursor', 'pointer')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended));

    // Node circles
    node.append('circle')
      .attr('r', d => d.id === currentPage ? 8 : 6)
      .attr('fill', d => d.id === currentPage ? colors.nodeCurrent : (sectionColors[d.section] || colors.node))
      .attr('stroke', '#fff')
      .attr('stroke-width', 2);

    // Node labels
    node.append('text')
      .text(d => d.title.length > 20 ? d.title.substring(0, 20) + '...' : d.title)
      .attr('x', 12)
      .attr('y', 4)
      .attr('font-size', '12px')
      .attr('fill', colors.text)
      .attr('pointer-events', 'none');

    // Hover effects
    node.on('mouseover', function(event, d) {
      d3.select(this).select('circle')
        .transition()
        .duration(200)
        .attr('r', 10);
    }).on('mouseout', function(event, d) {
      d3.select(this).select('circle')
        .transition()
        .duration(200)
        .attr('r', d.id === currentPage ? 8 : 6);
    }).on('click', function(event, d) {
      window.location.href = d.id;
    });

    // Update positions on tick
    simulation.on('tick', () => {
      link
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);

      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Drag functions
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGraph);
  } else {
    initGraph();
  }
})();
</script>
